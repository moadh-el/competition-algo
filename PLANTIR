#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <limits.h>

char* readline();
char* ltrim(char*);
char* rtrim(char*);
char** split_string(char*);
int parse_int(char*);

#define MAXN 200005
#define MAXM 400005

int head[MAXN];
int to[MAXM];
int weight[MAXM];
int next_edge[MAXM];
int ecnt = 0;

long long dista[MAXN];
int parent[MAXN];
int visited[MAXN];

typedef struct {
    long long d;
    int u;
} Node;

Node heap[MAXM];
int heap_size = 0;

void add_edge(int u, int v, int w) {
    ecnt++;
    to[ecnt] = v;
    weight[ecnt] = w;
    next_edge[ecnt] = head[u];
    head[u] = ecnt;
}

void push(int u, long long d) {
    heap_size++;
    int i = heap_size;
    while (i > 1) {
        int p = i / 2;
        if (heap[p].d <= d) break;
        heap[i] = heap[p];
        i = p;
    }
    heap[i].u = u;
    heap[i].d = d;
}

Node pop() {
    Node ret = heap[1];
    Node x = heap[heap_size--];
    int i = 1;
    while (2 * i <= heap_size) {
        int child = 2 * i;
        if (child < heap_size && heap[child+1].d < heap[child].d)
            child++;
        if (heap[child].d >= x.d) break;
        heap[i] = heap[child];
        i = child;
    }
    heap[i] = x;
    return ret;
}

void dijkstra(int start, int n) {
    for (int i = 1; i <= n; i++) {
        dista[i] = -1;
        visited[i] = 0;
        parent[i] = 0;
    }

    dista[start] = 0;
    push(start, 0);

    while (heap_size > 0) {
        Node top = pop();
        int u = top.u;

        if (visited[u]) continue;
        visited[u] = 1;

        for (int e = head[u]; e != 0; e = next_edge[e]) {
            int v = to[e];
            int w = weight[e];

            if (dista[v] == -1 || dista[u] + w < dista[v]) {
                dista[v] = dista[u] + w;
                parent[v] = u;
                push(v, dista[v]);
            }
        }
    }
}

void print_path(int t) {
    int stack[MAXN];
    int top = 0;
    int cur = t;

    while (cur != 0) {
        stack[top++] = cur;
        cur = parent[cur];
    }

    for (int i = top - 1; i >= 0; i--) {
        printf("%d", stack[i]);
        if (i > 0) printf(" ");
    }
    printf("\n");
}

int main() {
    char** first = split_string(rtrim(readline()));
    int N = parse_int(first[0]);
    int M = parse_int(first[1]);

    for (int i = 1; i <= N; i++) head[i] = 0;

    for (int i = 0; i < M; i++) {
        char** line = split_string(rtrim(readline()));
        int u = parse_int(line[0]);
        int v = parse_int(line[1]);
        int w = parse_int(line[2]);

        add_edge(u, v, w);
        add_edge(v, u, w);
    }

    char** last = split_string(rtrim(readline()));
    int s = parse_int(last[0]);
    int t = parse_int(last[1]);

    dijkstra(s, N);

    printf("%lld\n", dista[t]);
    print_path(t);

    return 0;
}

char* readline() {
    size_t size = 1024, len = 0;
    char* buffer = malloc(size);

    while (1) {
        char* ptr = buffer + len;
        if (!fgets(ptr, size - len, stdin)) break;
        len += strlen(ptr);
        if (len < size - 1 || buffer[len - 1] == '\n') break;
        size <<= 1;
        buffer = realloc(buffer, size);
    }
    if (buffer[len - 1] == '\n') buffer[len - 1] = '\0';
    return buffer;
}

char* ltrim(char* str) {
    while (*str && isspace(*str)) str++;
    return str;
}

char* rtrim(char* str) {
    int len = strlen(str) - 1;
    while (len >= 0 && isspace(str[len])) str[len--] = '\0';
    return str;
}

char** split_string(char* str) {
    char** res = NULL;
    int count = 0;
    char* tok = strtok(str, " ");
    while (tok) {
        res = realloc(res, sizeof(char*) * (++count));
        res[count - 1] = tok;
        tok = strtok(NULL, " ");
    }
    return res;
}

int parse_int(char* s) {
    return atoi(s);
}
